import os
import sys
import itertools
from collections import defaultdict, deque
from antlr4 import *
from antlr4.tree.Tree import TerminalNode # Import TerminalNode for type checking

try:
    # Adjust path if SimpleIR files are in the same directory or a specific location
    from SimpleIRLexer import SimpleIRLexer
    from SimpleIRParser import SimpleIRParser
    from SimpleIRListener import SimpleIRListener
except ImportError:
    # Fallback assuming they might be in a sub-package relative to the caller
    # Ensure this path is correct relative to where you run the script
    from simpleir.SimpleIRLexer import SimpleIRLexer
    from simpleir.SimpleIRParser import SimpleIRParser
    from simpleir.SimpleIRListener import SimpleIRListener


from antlr4.error.ErrorListener import ErrorListener
import logging
# Configure logging level (DEBUG shows detailed execution)
logging.basicConfig(level=logging.DEBUG)

# --- Runtime Error Helper ---
def runtime_error(msg):
    """Prints a runtime error message and exits."""
    sys.stderr.write(f"SimpleIR Runtime Error: {msg}\n")
    sys.exit(1)

# --- Syntax Error Listener Class ---
class SyntaxErrListener(ErrorListener):
    """Custom ANTLR listener to capture syntax errors."""
    def __init__(self):
        super().__init__()
        self.error_count = 0
        self.error_messages = []
    def syntaxError(self, recognizer, offendingSymbol, line, column, msg, e):
        """Callback for ANTLR syntax errors."""
        self.error_count += 1
        # Add context if possible (e.g., offendingSymbol text)
        offending_text = f"'{offendingSymbol.text}'" if offendingSymbol else ""
        self.error_messages.append(f"Syntax error at line {line}:{column} near {offending_text} - {msg}")


# --- Type Helper (Optional, not heavily used in this version) ---
def get_value_type(value):
    if isinstance(value, bool): return 'bool'
    if isinstance(value, int): return 'int'
    return 'unknown'
# --- Default Values (Optional) ---
DEFAULT_VALUES = {'int': 0, 'bool': False}

# --- Helper to safely get text from Token or TerminalNode ---
def safeGetText(node):
    """
    Gets text from ANTLR token/node, handling potential list wrapping
    and distinguishing between .text (for tokens) and .getText() (for contexts/terminals).
    """
    # Handle potential list wrapping FIRST
    if isinstance(node, list):
        if not node: runtime_error("safeGetText received an empty list.")
        node = node[0] # Assume first element if list
    if node is None: runtime_error("safeGetText received None node.")

    # Now node is guaranteed to be a single node/token object
    # Check for TerminalNode specifically, which needs .getText()
    if isinstance(node, TerminalNode):
         return node.getText()
    # Check if it's likely a raw Token (which has .text)
    elif hasattr(node, 'text') and not callable(node.text): # Check it's not the method itself
        return node.text
    # Fallback for other context objects that might have getText()
    elif hasattr(node, 'getText') and callable(node.getText):
         return node.getText()
    else:
        runtime_error(f"Cannot get text from node of type {type(node)}. Expected TerminalNode, Token, or Context with getText().")


# --- Helper to get the node itself, handling list wrapping ---
def getNode(node_or_list):
    """Returns the node, unwrapping if it's a single-element list."""
    if isinstance(node_or_list, list):
        if not node_or_list: runtime_error("getNode received an empty list.")
        return node_or_list[0]
    return node_or_list

# --- Interpreter Listener ---
class Interpreter(SimpleIRListener):
    """
    Executes SimpleIR code by walking the parse tree generated by ANTLR.
    Builds a list of runtime functions for instructions and then executes them.
    """
    def __init__(self):
        self.L = {} # Label map: label_name -> instruction_index
        self.P = [] # Program: list of runtime instruction functions
        self.name = None # Function name
        self.parameters = [] # List of parameter names
        self.localVariables = [] # List of local variable names
        self.retfunc = None # Function to compute return value
        self.functions = None # Link to other functions in the program unit
        # Runtime state (reinitialized in apply)
        self.memory = {} # Simulated memory: address -> value
        self.next_free_addr = 0 # Next available memory address

    def link(self, functions):
        """Links this function/module to the global functions dictionary."""
        self.functions = functions

    def _allocate_memory(self, size=1, init_val=0):
        """Allocates a block of memory."""
        if size <= 0: runtime_error("Allocation size must be positive.")
        start_addr = self.next_free_addr
        self.next_free_addr += size
        for i in range(size):
            self.memory[start_addr + i] = init_val
        logging.debug(f"    Allocated {size} words starting at M[{start_addr}]")
        return start_addr

    def _get_value(self, E, M, operand_node_or_list):
        """Gets the value of an operand (NAME or NUM) from environment/memory."""
        node = getNode(operand_node_or_list) # Ensure we have the node
        if node is None: runtime_error("Operand node is None in _get_value")

        # Determine the type of the operand node (token or terminal)
        # SimpleIRParser.NAME and NUM refer to token types defined in the lexer
        token_symbol = None
        # Check if it's a TerminalNode wrapping a token
        if isinstance(node, TerminalNode):
             token_symbol = node.symbol
        # Check if it's a raw Token itself (less common for operands here due to grammar structure)
        elif hasattr(node, 'type'):
             token_symbol = node

        if token_symbol is None:
            runtime_error(f"Cannot get token symbol from node {type(node)} in _get_value")

        token_text = safeGetText(node)

        if token_symbol.type == SimpleIRParser.NAME:
            var_name = token_text
            if var_name not in E:
                runtime_error(f"Variable '{var_name}' not defined in environment E.")
            var_info = E[var_name]
            addr = None
            # Check if var_info holds the address directly (temp var) or in a dict
            if isinstance(var_info, int):
                addr = var_info # Temp variable holds address directly
            elif isinstance(var_info, dict) and 'addr' in var_info:
                addr = var_info['addr'] # Scalar variable info
            # Note: Array base addresses aren't directly retrieved here, only scalar/temp addrs
            if addr is None:
                runtime_error(f"Cannot get memory address for scalar/temp variable '{var_name}'.")
            if addr not in M:
                # Check if it's an uninitialized read from within a known array (might be valid but risky)
                is_in_array = False
                for v, info_dict in E.items():
                    if isinstance(info_dict, dict) and info_dict.get('type') == 'array':
                        base = info_dict.get('base_addr')
                        size = info_dict.get('size')
                        if base is not None and size is not None and base <= addr < base + size:
                            logging.warning(f"Reading potentially uninitialized memory M[{addr}] for variable '{var_name}' (part of array '{v}'). Defaulting to 0.")
                            M[addr] = 0 # Default initialize on first read
                            is_in_array = True
                            break
                if not is_in_array:
                     runtime_error(f"Memory address {addr} for variable '{var_name}' not initialized.")

            return M[addr] # Return value from memory
        elif token_symbol.type == SimpleIRParser.NUM:
            return int(token_text) # Return integer value of the number
        else:
            # Provide symbolic name if possible for better error message
            token_name = SimpleIRParser.symbolicNames[token_symbol.type] if token_symbol.type < len(SimpleIRParser.symbolicNames) else str(token_symbol.type)
            runtime_error(f"Unexpected operand token type: {token_name}")


    def _get_address_from_var(self, E, var_name):
         """Gets the base address associated with a variable name (scalar, temp, or array)."""
         if var_name not in E:
             runtime_error(f"Variable '{var_name}' not defined.")
         var_info = E[var_name]
         if isinstance(var_info, int):
             return var_info # Temp variable holds address directly
         elif isinstance(var_info, dict):
             addr = var_info.get('addr') # Check for scalar address
             if addr is not None:
                 return addr
             base_addr = var_info.get('base_addr') # Check for array base address
             if base_addr is not None:
                 return base_addr
         # If no address found
         runtime_error(f"Cannot resolve '{var_name}' to a base memory address.")

    def apply(self, actuals):
        """Executes the compiled SimpleIR function."""
        logging.debug(f"Running SimpleIR function '{self.name}'")
        # Initialize Environment (E) and Memory (M) for this run
        E = {}
        self.memory = {}
        self.next_free_addr = 0

        # Allocate memory for parameters
        param_addrs = {}
        for param in self.parameters:
            addr = self._allocate_memory(1)
            E[param] = {'type': 'int', 'addr': addr} # Assume params are int for now
            param_addrs[param] = addr

        # Allocate memory for local variables
        for local in self.localVariables:
            if local in E: # Check for conflicts with parameters
                runtime_error(f"Local variable '{local}' conflicts with parameter name.")
            addr = self._allocate_memory(1)
            E[local] = {'type': 'int', 'addr': addr} # Assume locals are int for now

        # Check argument count
        if len(actuals) != len(self.parameters):
            runtime_error(f"Argument count mismatch for function '{self.name}'. Expected {len(self.parameters)}, got {len(actuals)}")

        # Assign actual parameter values to parameter memory locations
        for param_name, actual_value in zip(self.parameters, actuals):
            try:
                # Ensure actuals are integers for this simple interpreter
                actual_value = int(actual_value)
            except ValueError:
                runtime_error(f"Cannot convert actual parameter '{actual_value}' to int for parameter '{param_name}'.")
            param_addr = E[param_name]['addr']
            self.memory[param_addr] = actual_value
            logging.debug(f"  Param '{param_name}' at M[{param_addr}] = {actual_value}")

        logging.debug(f"  Initial Environment E: {E}")
        logging.debug(f"  Initial Memory M: {self.memory}")

        # Execute instructions
        i = 0 # Program counter
        instruction_count = 0
        MAX_INSTRUCTIONS = 10000 # Safety limit against infinite loops

        while 0 <= i < len(self.P):
            if instruction_count > MAX_INSTRUCTIONS:
                runtime_error(f"Maximum instruction limit ({MAX_INSTRUCTIONS}) exceeded. Possible infinite loop.")
            # Execute the runtime function for the current instruction
            # It takes the current Environment, Memory, and PC, and returns the updated E and next PC
            E, next_i = self.P[i](E, self.memory, i)
            instruction_count += 1
            i = next_i # Update program counter

        # Get return value
        retval = self.retfunc(E, self.memory) if self.retfunc else 0 # Default return 0 if no return statement

        # --- MODIFIED DEBUG OUTPUT FOR FINAL STATE ---
        logging.debug("memory:") # Changed label
        # Build reverse mapping from address to name
        addr_to_name = {}
        for name, info in E.items():
            if isinstance(info, int): # Temp var address
                addr_to_name[info] = name
            elif isinstance(info, dict):
                addr = info.get('addr') # Scalar address
                if addr is not None:
                    addr_to_name[addr] = name
                else:
                    base_addr = info.get('base_addr') # Array base address
                    if base_addr is not None:
                         # Mark the base address with the array name
                         addr_to_name[base_addr] = f"{name}[base]" # Indicate it's an array base

        # Print memory contents with names
        for addr in sorted(self.memory.keys()):
            value = self.memory[addr]
            name_str = addr_to_name.get(addr, '?') # Find name, default to '?'
            # Special check if name_str is still '?' but addr might be inside an array
            if name_str == '?':
                 for b_addr, b_name in addr_to_name.items():
                     if isinstance(b_name, str) and b_name.endswith("[base]"): # Check if it's an array base marker
                         array_name = b_name[:-6] # Get original array name
                         if array_name in E and isinstance(E[array_name], dict):
                             array_info = E[array_name]
                             array_base = array_info.get('base_addr')
                             array_size = array_info.get('size')
                             if array_base is not None and array_size is not None:
                                 if array_base < addr < array_base + array_size:
                                     # Address is inside this array, but not the base
                                     name_str = f"{array_name}[{addr - array_base}]"
                                     break # Found array element mapping

            logging.debug(f"  M({addr}): {value} ({name_str})") # Use new format

        logging.debug(f"return value: {retval}") # Changed label
        # --- END MODIFIED DEBUG OUTPUT ---

        return retval

    # --- Listener Methods ---
    # These methods are called by the ParseTreeWalker as it enters/exits grammar rules.
    # They build the program list (self.P) and label map (self.L).

    def exitUnit(self, ctx:SimpleIRParser.UnitContext):
        """Called after visiting the whole unit."""
        pass # Nothing special needed here

    def enterFunction(self, ctx:SimpleIRParser.FunctionContext):
        """Called when entering a function definition."""
        # functionName is assigned token (name=TOKEN) -> use .text
        self.name = ctx.functionName.text if ctx.functionName else "anonymous_function"
        logging.debug(f"Entering function: {self.name}")
        # Reset state for the new function
        self.L = {}
        self.P = []
        self.parameters = []
        self.localVariables = []
        self.retfunc = None
        # Runtime state is reset in apply()

    def exitFunction(self, ctx:SimpleIRParser.FunctionContext):
        """Called after visiting a function definition."""
        logging.debug(f"Exiting function: {self.name}")

    def enterLocalVariables(self, ctx:SimpleIRParser.LocalVariablesContext):
        """Extracts local variable names."""
        # ctx.NAME() returns a list of TerminalNodeImpl objects -> use .getText()
        self.localVariables = [ name_node.getText() for name_node in ctx.NAME() ]
        logging.debug(f"  Local Vars: {self.localVariables}")

    def enterParameters(self, ctx:SimpleIRParser.ParametersContext):
        """Extracts parameter names."""
         # ctx.NAME() returns a list of TerminalNodeImpl objects -> use .getText()
        self.parameters = [ name_node.getText() for name_node in ctx.NAME() ]
        logging.debug(f"  Parameters: {self.parameters}")

    def enterReturnStatement(self, ctx:SimpleIRParser.ReturnStatementContext):
        """Sets up the function to calculate the return value."""
        # operand is assigned: operand=(NAME | NUM), so it's a token or terminal node
        operand_node = ctx.operand # This will be a Token (NAME or NUM)
        def retfunc(E, M):
            # Use _get_value to handle NAME or NUM
            return self._get_value(E, M, operand_node)
        self.retfunc = retfunc

    # --- Instruction Handling ---
    # These methods are called when entering specific instruction rules (via labels).
    # They append a lambda function to self.P that performs the runtime action.

    def _ensure_var_allocated(self, E, M, var_node_or_list):
        """Ensures temporary variables are allocated in E and M when first assigned."""
        node = getNode(var_node_or_list) # Ensure we have the node
        var_name = safeGetText(node)
        if var_name not in E:
            # Only dynamically allocate temps (_t...)
            if var_name.startswith('_t'):
                 addr = self._allocate_memory(1)
                 # Store address directly in E for temps for simplicity
                 E[var_name] = addr
                 logging.debug(f"    Dynamically allocated temp '{var_name}' at M[{addr}]")
            else:
                # This should ideally not happen if locals/params are handled correctly
                runtime_error(f"Variable '{var_name}' not defined (and not a temp starting with _t).")
        return E

    def enterAssignInstr(self, ctx: SimpleIRParser.AssignInstrContext):
        """Handles 'NAME := operand' instruction."""
        inner_ctx = ctx.assign()
        # lhs is NAME() terminal node -> use .getText()
        lhs_node = inner_ctx.NAME()
        # rhs is assigned operand token/terminal -> use .text/.getText() via safeGetText
        rhs_node_or_list = inner_ctx.operand

        def assign_runtime(E, M, i):
            lhs_name = safeGetText(lhs_node)
            # Ensure var exists (could be local, param, or temp being assigned)
            E = self._ensure_var_allocated(E, M, lhs_node)
            lhs_addr = self._get_address_from_var(E, lhs_name)
            rhs_value = self._get_value(E, M, rhs_node_or_list) # Get value of RHS
            M[lhs_addr] = rhs_value # Store value in memory
            logging.debug(f"    Exec: {lhs_name} (M[{lhs_addr}]) := {rhs_value}")
            return E, i + 1 # Return updated E and next PC
        self.P.append(assign_runtime) # Add the runtime function to the program list

    def enterDereferenceInstr(self, ctx: SimpleIRParser.DereferenceInstrContext):
        """Handles 'NAME := *NAME' instruction."""
        inner_ctx = ctx.dereference()
        # lhs = NAME(0), addr_var = NAME(1) are terminal nodes -> use .getText()
        lhs_node = inner_ctx.NAME(0)
        addr_var_node = inner_ctx.NAME(1)

        def dereference_runtime(E, M, i):
            lhs_name = safeGetText(lhs_node)
            addr_var_name = safeGetText(addr_var_node)
            # Ensure LHS exists
            E = self._ensure_var_allocated(E, M, lhs_node)
            lhs_addr = self._get_address_from_var(E, lhs_name)
            # Get the address stored in the address variable
            address_to_read = self._get_value(E, M, addr_var_node)
            if not isinstance(address_to_read, int):
                runtime_error(f"Variable '{addr_var_name}' does not hold a valid address for dereference (*).")
            if address_to_read not in M:
                runtime_error(f"Invalid memory address {address_to_read} encountered during dereference of '{addr_var_name}'.")
            # Read value from memory at the address
            value_read = M[address_to_read]
            M[lhs_addr] = value_read # Store the read value into LHS
            logging.debug(f"    Exec: {lhs_name} (M[{lhs_addr}]) := *{addr_var_name} (M[{address_to_read}]) = {value_read}")
            return E, i + 1
        self.P.append(dereference_runtime)

    def enterReferenceInstr(self, ctx: SimpleIRParser.ReferenceInstrContext):
        """Handles 'NAME := &NAME' instruction."""
        inner_ctx = ctx.reference()
        # lhs = NAME(0), addr_of = NAME(1) are terminal nodes -> use .getText()
        lhs_node = inner_ctx.NAME(0)
        addr_of_node = inner_ctx.NAME(1)

        def reference_runtime(E, M, i):
            lhs_name = safeGetText(lhs_node)
            addr_of_name = safeGetText(addr_of_node)
             # Ensure LHS exists
            E = self._ensure_var_allocated(E, M, lhs_node)
            lhs_addr = self._get_address_from_var(E, lhs_name)
            # Get the address OF the variable addr_of_name
            addr_to_store = self._get_address_from_var(E, addr_of_name)
            M[lhs_addr] = addr_to_store # Store the address
            logging.debug(f"    Exec: {lhs_name} (M[{lhs_addr}]) := &{addr_of_name} (@{addr_to_store})")
            return E, i + 1
        self.P.append(reference_runtime)

    def enterAssignDereferenceInstr(self, ctx: SimpleIRParser.AssignDereferenceInstrContext):
        """Handles '*NAME := operand' instruction."""
        inner_ctx = ctx.assignDereference()
        # addr_var = NAME() is terminal node -> use .getText()
        addr_var_node = inner_ctx.NAME()
        # rhs is assigned operand token/terminal -> use safeGetText
        rhs_node_or_list = inner_ctx.operand

        def assign_dereference_runtime(E, M, i):
            addr_var_name = safeGetText(addr_var_node)
            # Get the address stored in the address variable
            address_to_write = self._get_value(E, M, addr_var_node)
            if not isinstance(address_to_write, int):
                runtime_error(f"Variable '{addr_var_name}' does not hold a valid address for dereference assignment (* ... := ).")
            if address_to_write not in M:
                 runtime_error(f"Invalid memory address {address_to_write} encountered during dereference assignment of '{addr_var_name}'.")
            # Get the value of the RHS
            rhs_value = self._get_value(E, M, rhs_node_or_list)
            # Store the RHS value into memory at the address
            M[address_to_write] = rhs_value
            logging.debug(f"    Exec: *{addr_var_name} (M[{address_to_write}]) := {rhs_value}")
            return E, i + 1
        self.P.append(assign_dereference_runtime)

    def enterOperationInstr(self, ctx: SimpleIRParser.OperationInstrContext):
        """Handles 'NAME := NAME op NAME' instruction."""
        inner_ctx = ctx.operation()
        # lhs=NAME(0), op1=NAME(1), op2=NAME(2) are terminals -> use .getText()
        lhs_node = inner_ctx.NAME(0)
        op1_node = inner_ctx.NAME(1)
        op2_node = inner_ctx.NAME(2)
        # op_kind is assigned token (op=TOKEN) -> use .text
        op_kind_token = inner_ctx.operatorKind

        def operation_runtime(E, M, i):
            lhs_name = safeGetText(lhs_node)
            # Ensure LHS exists
            E = self._ensure_var_allocated(E, M, lhs_node)
            lhs_addr = self._get_address_from_var(E, lhs_name)
            # Get values of operands
            operand1 = self._get_value(E, M, op1_node)
            operand2 = self._get_value(E, M, op2_node)
            # Determine operation from token type
            op_type = op_kind_token.type
            op_text = safeGetText(op_kind_token) # Get operator text for logging (.text)
            val = 0 # Default value

            if op_type == SimpleIRParser.PLUS: val = operand1 + operand2
            elif op_type == SimpleIRParser.MINUS: val = operand1 - operand2
            elif op_type == SimpleIRParser.STAR: val = operand1 * operand2
            elif op_type == SimpleIRParser.SLASH:
                if operand2 == 0: runtime_error("Division by zero."); val = 0 # Or handle differently
                else: val = operand1 // operand2 # Integer division
            elif op_type == SimpleIRParser.PERCENT:
                if operand2 == 0: runtime_error("Modulo by zero."); val = 0 # Or handle differently
                else: val = operand1 % operand2
            else:
                runtime_error(f"Unknown operation operator type: {op_type}")

            M[lhs_addr] = int(val) # Store result
            logging.debug(f"    Exec: {lhs_name} (M[{lhs_addr}]) := {operand1} {op_text} {operand2} = {val}")
            return E, i + 1
        self.P.append(operation_runtime)

    def enterCallInstr(self, ctx:SimpleIRParser.CallInstrContext):
        """Handles 'NAME := call NAME NAME*' instruction."""
        inner_ctx = ctx.call()
        # lhs=NAME(0), func_name=NAME(1) are terminals -> use .getText()
        lhs_node = inner_ctx.NAME(0)
        func_name_node = inner_ctx.NAME(1)
        # args are remaining NAME() terminals -> use .getText()
        arg_nodes = inner_ctx.NAME()[2:]

        def call_runtime(E, M, i):
            lhs_name = safeGetText(lhs_node)
            func_name = safeGetText(func_name_node)
             # Ensure LHS exists
            E = self._ensure_var_allocated(E, M, lhs_node)
            lhs_addr = self._get_address_from_var(E, lhs_name)
            # Evaluate actual arguments
            actuals = [ self._get_value(E, M, arg_node) for arg_node in arg_nodes ]

            if func_name not in self.functions:
                runtime_error(f"Call to undefined function '{func_name}'.")

            logging.debug(f"    Exec: Calling {func_name} with args {actuals}")
            # Call the linked function's apply method
            return_value = self.functions[func_name].apply(actuals)
            logging.debug(f"    Exec: {func_name} returned {return_value}")
            # Store return value (ensure it's an int)
            M[lhs_addr] = int(return_value) if return_value is not None else 0
            logging.debug(f"    Exec: {lhs_name} (M[{lhs_addr}]) := return value {M[lhs_addr]}")
            return E, i + 1
        self.P.append(call_runtime)

    def enterLabelInstr(self, ctx:SimpleIRParser.LabelInstrContext):
        """Handles 'NAME:' instruction."""
        inner_ctx = ctx.label()
        # label name is NAME() terminal -> use .getText()
        label_name_node = inner_ctx.NAME()
        label_name = safeGetText(label_name_node)
        if label_name in self.L:
            runtime_error(f"Duplicate label definition: '{label_name}'")
        # Store instruction index (current length of P) for this label
        self.L[label_name] = len(self.P)
        logging.debug(f"  Label '{label_name}' defined at instruction index {self.L[label_name]}")
        # Labels don't generate a runtime function, they just mark a point

    def enterGotoInstr(self, ctx:SimpleIRParser.GotoInstrContext):
        """Handles 'goto NAME' instruction."""
        inner_ctx = ctx.gotoStatement()
        # label name is NAME() terminal -> use .getText()
        label_name_node = inner_ctx.NAME()

        def goto_runtime(E, M, i):
            label_name = safeGetText(label_name_node)
            if label_name not in self.L:
                runtime_error(f"Goto target label '{label_name}' not found.")
            next_i = self.L[label_name] # Get target instruction index
            logging.debug(f"    Exec: goto {label_name} (instruction {next_i})")
            # Return E (unchanged) and the target instruction index
            return E, next_i
        self.P.append(goto_runtime)

    # <<< MODIFIED enterIfGotoInstr >>>
    def enterIfGotoInstr(self, ctx:SimpleIRParser.IfGotoInstrContext):
        """Handles 'if operand op operand goto NAME' instruction."""
        inner_ctx = ctx.ifGoto()
        # Operands are assigned tokens/terminals -> use safeGetText
        op1_node = inner_ctx.operand1
        op2_node = inner_ctx.operand2
        # Operator kind is assigned token -> use safeGetText
        op_kind_token = inner_ctx.operatorKind
        # Label name is the LAST NAME() terminal node -> use .getText()
        name_nodes = inner_ctx.NAME() # Get all NAME nodes
        if not name_nodes or len(name_nodes) == 0:
             runtime_error("Internal: Missing NAME node for label in ifGoto.")
        label_name_node = name_nodes[-1] # <<< Get the LAST NAME node for the label

        def ifGoto_runtime(E, M, i):
            # Evaluate operands
            operand1 = self._get_value(E, M, op1_node)
            operand2 = self._get_value(E, M, op2_node)
            # Get operator type and target label name
            op_type = op_kind_token.type
            op_text = safeGetText(op_kind_token) # For logging
            label_name = safeGetText(label_name_node) # <<< Use the correct node

            if label_name not in self.L:
                runtime_error(f"IfGoto target label '{label_name}' not found.") # <<< Error fixed here
            target_i = self.L[label_name] # Target instruction index if true

            # Comparison logic based on operator type
            ops = { SimpleIRParser.EQ: lambda a,b:a==b,
                    SimpleIRParser.NEQ: lambda a,b:a!=b,
                    SimpleIRParser.LT: lambda a,b:a<b,
                    SimpleIRParser.LTE: lambda a,b:a<=b,
                    SimpleIRParser.GT: lambda a,b:a>b,
                    SimpleIRParser.GTE: lambda a,b:a>=b }

            if op_type not in ops:
                runtime_error(f"Unknown IfGoto operator type: {op_type}")

            result = ops[op_type](operand1, operand2) # Perform comparison
            next_i = target_i if result else i + 1 # Jump if true, else continue

            logging.debug(f"    Exec: if {operand1} {op_text} {operand2} is {result}, goto {label_name} ({target_i}) else continue ({i+1}) -> next PC={next_i}")
            return E, next_i # Return E and next PC
        self.P.append(ifGoto_runtime)


    # --- Array Instruction Handlers ---

    def enterAllocInstr(self, ctx: SimpleIRParser.AllocInstrContext):
        """Handles 'alloc NAME, NUM' instruction."""
        inner_ctx = ctx.allocStmt()
        # var_name = NAME() terminal -> use .getText()
        var_name_node = inner_ctx.NAME()
        # size = NUM() terminal -> use .getText()
        size_node = inner_ctx.NUM()

        def alloc_runtime(E, M, i):
            var_name = safeGetText(var_name_node)
            size = int(safeGetText(size_node))
            if size <=0:
                runtime_error(f"alloc size must be positive for '{var_name}'.")
            if var_name in E:
                # Should not happen if IRGen prevents re-declaration, but check anyway
                runtime_error(f"Variable '{var_name}' already allocated/defined.")
            # Allocate memory block
            base_addr = self._allocate_memory(size, init_val=0) # Initialize array elements to 0
            # Store array info (base address, size) in environment E
            E[var_name] = {'type': 'array', 'base_addr': base_addr, 'size': size, 'elem_size': 1, 'elem_type': 'int'} # Assume int array
            logging.debug(f"    Exec: alloc {var_name}, {size}. Base address: {base_addr}.")
            return E, i + 1
        self.P.append(alloc_runtime)

    def enterAddrInstr(self, ctx: SimpleIRParser.AddrInstrContext):
        """Handles 'NAME := addr NAME, NAME' instruction."""
        inner_ctx = ctx.addrStmt()
        # result=NAME(0), base=NAME(1), index=NAME(2) are terminals -> use .getText()
        result_addr_node = inner_ctx.NAME(0)
        base_name_node = inner_ctx.NAME(1)
        index_name_node = inner_ctx.NAME(2)

        def addr_runtime(E, M, i):
            result_addr_name = safeGetText(result_addr_node)
            base_name = safeGetText(base_name_node)
            index_name = safeGetText(index_name_node)

            # Ensure result variable exists (must be temp or local/param)
            E = self._ensure_var_allocated(E, M, result_addr_node)
            result_mem_addr = self._get_address_from_var(E, result_addr_name) # Get address where result will be stored

            # Check if base is a declared array
            if base_name not in E or not isinstance(E[base_name], dict) or E[base_name].get('type') != 'array':
                runtime_error(f"Base variable '{base_name}' for addr instruction is not a declared array.")

            base_info = E[base_name]
            base_mem_addr = base_info['base_addr']
            array_size = base_info['size']
            elem_size = base_info.get('elem_size', 1) # Assume element size 1 (word) if not specified

            # Get the integer value of the index variable/temporary
            index_value = self._get_value(E, M, index_name_node)
            if not isinstance(index_value, int):
                runtime_error(f"Index variable '{index_name}' must hold an integer value for addr instruction.")

            # Bounds check
            if not (0 <= index_value < array_size):
                runtime_error(f"Array index out of bounds for '{base_name}': index={index_value}, size={array_size}.")

            # Calculate target address
            target_addr = base_mem_addr + (index_value * elem_size)
            # Store the calculated address in the result variable's memory location
            M[result_mem_addr] = target_addr

            logging.debug(f"    Exec: {result_addr_name} (M[{result_mem_addr}]) := addr {base_name}(@{base_mem_addr}) , {index_name}({index_value}) = {target_addr}")
            return E, i + 1
        self.P.append(addr_runtime)

    def enterLoadInstr(self, ctx: SimpleIRParser.LoadInstrContext):
        """Handles 'NAME := load NAME' instruction."""
        inner_ctx = ctx.loadStmt()
        # result=NAME(0), address_var=NAME(1) are terminals -> use .getText()
        result_val_node = inner_ctx.NAME(0)
        address_name_node = inner_ctx.NAME(1)

        def load_runtime(E, M, i):
            result_val_name = safeGetText(result_val_node)
            address_name = safeGetText(address_name_node)

            # Ensure result variable exists
            E = self._ensure_var_allocated(E, M, result_val_node)
            result_mem_addr = self._get_address_from_var(E, result_val_name) # Address to store loaded value

            # Get the address TO LOAD FROM (held in address_name variable)
            address_to_load_from = self._get_value(E, M, address_name_node)
            if not isinstance(address_to_load_from, int):
                runtime_error(f"Variable '{address_name}' used in load instruction does not contain a valid address.")
            if address_to_load_from not in M:
                runtime_error(f"Invalid memory address {address_to_load_from} encountered during load from '{address_name}'.")

            # Perform the load
            loaded_value = M[address_to_load_from]
            # Store the loaded value into the result variable's memory location
            M[result_mem_addr] = loaded_value

            logging.debug(f"    Exec: {result_val_name} (M[{result_mem_addr}]) := load {address_name} (M[{address_to_load_from}]) = {loaded_value}")
            return E, i + 1
        self.P.append(load_runtime)

    def enterStoreInstr(self, ctx: SimpleIRParser.StoreInstrContext):
        """Handles 'store NAME, NAME' instruction."""
        inner_ctx = ctx.storeStmt()
        # value_var=NAME(0), address_var=NAME(1) are terminals -> use .getText()
        value_name_node = inner_ctx.NAME(0)
        address_name_node = inner_ctx.NAME(1)

        def store_runtime(E, M, i):
            value_name = safeGetText(value_name_node)
            address_name = safeGetText(address_name_node)

            # Get the value to store (from value_name variable)
            value_to_store = self._get_value(E, M, value_name_node)
            # Get the address TO STORE TO (held in address_name variable)
            address_to_store_to = self._get_value(E, M, address_name_node)

            if not isinstance(address_to_store_to, int):
                runtime_error(f"Variable '{address_name}' used in store instruction does not contain a valid address.")
            # Check if address is valid (i.e., allocated)
            if address_to_store_to not in M:
                 # Check if it falls within a known array's bounds as a fallback
                 is_in_array = False
                 for var, info in E.items():
                     if isinstance(info, dict) and info.get('type') == 'array':
                         base = info.get('base_addr')
                         size = info.get('size')
                         if base is not None and size is not None:
                             if base <= address_to_store_to < base + size:
                                 is_in_array = True
                                 # If it's within bounds but not yet in M, initialize it
                                 # This allows storing into previously unwritten array slots
                                 M[address_to_store_to] = 0 # Default initialize before overwrite
                                 break
                 if not is_in_array:
                     runtime_error(f"Invalid memory address {address_to_store_to} encountered during store to '{address_name}'. Address not allocated.")

            # Perform the store
            M[address_to_store_to] = value_to_store

            logging.debug(f"    Exec: store {value_name}({value_to_store}), {address_name} (M[{address_to_store_to}])")
            return E, i + 1
        self.P.append(store_runtime)


# --- BuiltIn Class ---
class BuiltIn:
    """Wrapper for built-in functions like print_int, read_int."""
    def __init__(self, applyfunc):
        self.applyfunc = applyfunc
    def apply(self, args):
        """Executes the built-in function."""
        return self.applyfunc(args)
    def link(self, functions):
        """Built-ins don't need linking."""
        pass

# --- Main function ---
def main():
    """Parses SimpleIR file(s) and executes the 'main' function."""
    import sys
    # Determine input source(s)
    if len(sys.argv) > 1:
        # Read from file arguments
        filepaths = sys.argv[1:]
        # Use a dictionary to handle potential duplicate filenames gracefully
        streams = {}
        for filepath in filepaths:
             # Check if file exists before attempting to open
             if not os.path.exists(filepath):
                 print(f"Error: Input file not found: {filepath}", file=sys.stderr)
                 exit(1)
             streams[os.path.basename(filepath)] = FileStream(filepath, encoding='utf-8')
    else:
        # Read from standard input
        input_stream = StdinStream()
        filename = "stdin"
        streams = { filename: input_stream }

    # Dictionary to hold all functions (including built-ins)
    functions = {}
    # Add built-in functions
    # Ensure built-ins handle potential type errors gracefully if needed
    functions["print_int"] = BuiltIn(lambda args: print(args[0] if args else "Error: print_int requires 1 argument"))
    functions["read_int"] = BuiltIn(lambda args: int(input(""))) # Simple blocking read

    # Parse each input stream/file
    for filename, input_stream in streams.items():
        logging.debug(f"Processing IR file: {filename}")
        lexer = SimpleIRLexer(input_stream)
        stream = CommonTokenStream(lexer)
        parser = SimpleIRParser(stream)
        parser.removeErrorListeners() # Remove default listener
        error_listener = SyntaxErrListener() # Add custom listener
        parser.addErrorListener(error_listener)

        tree = parser.unit() # Start parsing from the 'unit' rule

        # Check for syntax errors
        if error_listener.error_count > 0:
            print(f"Syntax errors in '{filename}':", file=sys.stderr)
            for err in error_listener.error_messages:
                print(f"- {err}", file=sys.stderr)
            exit(1) # Exit if syntax errors found

        # Walk the parse tree using the Interpreter listener
        walker = ParseTreeWalker()
        interp = Interpreter() # Create a new interpreter instance for this file/unit
        walker.walk(interp, tree)

        # Store the parsed function (assuming one function per file for now)
        if not interp.name:
             # Assign a default name if the function definition was empty or malformed
             interp.name = f"module_{filename.replace('.', '_')}"
        if interp.name in functions and not isinstance(functions[interp.name], BuiltIn):
             logging.warning(f"Redefinition of function '{interp.name}' from file '{filename}'. Overwriting previous definition.")
        functions[interp.name] = interp

    # Link functions (allow calls between functions)
    for function in functions.values():
        # Pass the global functions dictionary to each function object
        if hasattr(function, 'link'): # Check if it's an Interpreter or BuiltIn
             function.link(functions)

    # Find and execute the 'main' function
    if "main" not in functions:
        print("Error: No 'main' function found.", file=sys.stderr)
        exit(1)
    if not hasattr(functions["main"], 'apply'):
         print("Error: 'main' is not a callable function (maybe a parsing issue?).", file=sys.stderr)
         exit(1)


    logging.debug("Starting execution from 'main'")
    # Execute 'main' with no arguments
    try:
        exitcode = functions["main"].apply([])
        # Exit with the integer return code from 'main'
        exit(exitcode if isinstance(exitcode, int) else 0)
    except Exception as e:
        # Catch potential runtime errors during execution that weren't caught by runtime_error
        sys.stderr.write(f"\nUnhandled Runtime Error during execution: {e}\n")
        import traceback
        sys.stderr.write(traceback.format_exc())
        exit(1)


if __name__ == '__main__':
    main()